#!/bin/bash

### pafs Usage:help
# 
# Search for packages everywhere!
# 
# (C) Tai Kedzierski, released under GPL v3
# 
# 
# 
# This script was inspired by the "Universal xkcd installer"
# 
# Rather than installing packages however, it searches a wide range of sources, including (as apporpriate):
# 
# 
# * standard repositories for apt, dnf/yum, pacman, tazpkg and emerge systems
# * AUR if yaourt is detected, in which case yaourt search is used instead of pacman
# * Where detected, cpan (this needs to have been initialized first), pear, pip, ruby gems, npm
# * searches for local .deb and .rpm files depending on detection of apt-get or yum/dnf
# * performs a basic web search for github repositories
# * and finally looks for directories with "Makefile" or "install.sh" files
# 
# The results are then displayed in `less`, and you can see which repositories or locations yeilded a result.
# 
# OPTIONS
# 
# --update|-u
# 	Whether to run the package list update mechanism, if appropriate
# 
# --filter|-f
# 	filter results using a perl-style regular expression (`grep -P`)
# 
# --help|-h
# 	Prints this help
###/doc

#!/bin/bash

### autohelp:print [ SECTION [FILE] ] Usage:bbuild
# Write your help as documentation comments in your script
#
# If you need to output the help from your script, or a file, call the
# `autohelp:print` function and it will print the help documentation
# in the current script to stdout
#
# A help comment looks like this:
#
#	### <title> Usage:help
#	#
#	# <some content>
#	#
#	# end with "###/doc" on its own line (whitespaces before
#	# and after are OK)
#	#
#	###/doc
#
# You can set a different help section by specifying a subsection
#
# 	autohelp:print section2
#
# > This would print a section defined in this way:
#
# 	### Some title Usage:section2
# 	# <some content>
# 	###/doc
#
# You can set a different comment character by setting the 'HELPCHAR' environment variable:
#
# 	HELPCHAR=%
#
###/doc

HELPCHAR='#'

function autohelp:print {
	local SECTION_STRING="${1:-}"; shift || :
	local TARGETFILE="${1:-}"; shift || :
	[[ -n "$SECTION_STRING" ]] || SECTION_STRING=help
	[[ -n "$TARGETFILE" ]] || TARGETFILE="$0"

        echo -e "\n$(basename "$TARGETFILE")\n===\n"
        local SECSTART='^\s*'"$HELPCHAR$HELPCHAR$HELPCHAR"'\s+(.+?)\s+Usage:'"$SECTION_STRING"'\s*$'
        local SECEND='^\s*'"$HELPCHAR$HELPCHAR$HELPCHAR"'\s*/doc\s*$'
        local insec=false

        while read secline; do
                if [[ "$secline" =~ $SECSTART ]]; then
                        insec=true
                        echo -e "\n${BASH_REMATCH[1]}\n---\n"

                elif [[ "$insec" = true ]]; then
                        if [[ "$secline" =~ $SECEND ]]; then
                                insec=false
                        else
				echo "$secline" | sed -r "s/^\s*$HELPCHAR//g"
                        fi
                fi
        done < "$TARGETFILE"

        if [[ "$insec" = true ]]; then
                echo "WARNING: Non-terminated help block." 1>&2
        fi
	echo ""
}

### autohelp:paged Usage:bbuild
#
# Display the help in the pager defined in the PAGER environment variable
#
###/doc
function autohelp:paged {
	: ${PAGER=less}
	autohelp:print "$@" | $PAGER
}

### autohelp:check Usage:bbuild
#
# Automatically print help and exit if "--help" is detected in arguments
#
# Example use:
#
#	#!/bin/bash
#
#	### Some help Usage:help
#	#
#	# Some help text
#	#
#	###/doc
#
#	#%include autohelp.sh
#
#	main() {
#		autohelp:check "$@"
#
#		# now add your code
#	}
#
#	main "$@"
#
###/doc
autohelp:check() {
	if [[ "$*" =~ --help ]]; then
		cols="$(tput cols)"
		autohelp:print | fold -w "$cols" -s || autohelp:print
		exit 0
	fi
}
#!/bin/bash

#!/bin/bash

### Colours for bash Usage:bbuild
# A series of colour flags for use in outputs.
#
# Example:
# 	
# 	echo -e "${CRED}Some red text ${CBBLU} some blue text $CDEF some text in the terminal's default colour"
#
# Requires processing of escape characters.
#
# Colours available:
#
# CRED, CBRED, HLRED -- red, bold red, highlight red
# CGRN, CBGRN, HLGRN -- green, bold green, highlight green
# CYEL, CBYEL, HLYEL -- yellow, bold yellow, highlight yellow
# CBLU, CBBLU, HLBLU -- blue, bold blue, highlight blue
# CPUR, CBPUR, HLPUR -- purple, bold purple, highlight purple
# CTEA, CBTEA, HLTEA -- teal, bold teal, highlight teal
#
# CDEF -- switches to the terminal default
# CUNL -- add underline
#
# Note that highlight and underline must be applied or re-applied after specifying a colour.
#
###/doc

export CRED="\033[0;31m"
export CGRN="\033[0;32m"
export CYEL="\033[0;33m"
export CBLU="\033[0;34m"
export CPUR="\033[0;35m"
export CTEA="\033[0;36m"

export CBRED="\033[1;31m"
export CBGRN="\033[1;32m"
export CBYEL="\033[1;33m"
export CBBLU="\033[1;34m"
export CBPUR="\033[1;35m"
export CBTEA="\033[1;36m"

export HLRED="\033[41m"
export HLGRN="\033[42m"
export HLYEL="\033[43m"
export HLBLU="\033[44m"
export HLPUR="\033[45m"
export HLTEA="\033[46m"

export CDEF="\033[0m"

### Console output handlers Usage:bbuild
#
# Write data to console stderr using colouring
#
###/doc

### Environment Variables Usage:bbuild
#
# MODE_DEBUG : set to 'true' to enable debugging output
# MODE_DEBUG_VERBOSE : set to 'true' to enable command echoing
#
###/doc

: ${MODE_DEBUG=false}
: ${MODE_DEBUG_VERBOSE=false}

# Internal
function out:buffer_initialize {
	OUTPUT_BUFFER_defer=(:)
}
out:buffer_initialize

### out:debug MESSAGE Usage:bbuild
# print a blue debug message to stderr
# only prints if MODE_DEBUG is set to "true"
###/doc
function out:debug {
	if [[ "$MODE_DEBUG" = true ]]; then
		echo -e "${CBBLU}DEBUG: $CBLU$*$CDEF" 1>&2
	fi
}

### out:debug:fork [MARKER] Usage:bbuild
#
# Pipe the data coming through stdin to stdout
#
# If debug mode is on, *also* write the same data to stderr, each line preceded by MARKER
#
# Insert this debug fork into pipes to see their output
#
###/doc
function out:debug:fork {
	if [[ "$MODE_DEBUG" = true ]]; then
		local MARKER="${1:-DEBUG: }"; shift || :

		cat - | sed -r "s/^/$MARKER/" | tee -a /dev/stderr
	else
		cat -
	fi
}

### out:info MESSAGE Usage:bbuild
# print a green informational message to stderr
###/doc
function out:info {
	echo -e "$CGRN$*$CDEF" 1>&2
}

### out:warn MESSAGE Usage:bbuild
# print a yellow warning message to stderr
###/doc
function out:warn {
	echo -e "${CBYEL}WARN: $CYEL$*$CDEF" 1>&2
}

### out:defer MESSAGE Usage:bbuild
# Store a message in the output buffer for later use
###/doc
function out:defer {
	OUTPUT_BUFFER_defer[${#OUTPUT_BUFFER_defer[@]}]="$*"
}

### out:flush HANDLER ... Usage:bbuild
#
# Pass the output buffer to the command defined by HANDLER
# and empty the buffer
#
# Examples:
#
# 	out:flush echo -e
#
# 	out:flush out:warn
#
# (escaped newlines are added in the buffer, so `-e` option is
#  needed to process the escape sequences)
#
###/doc
function out:flush {
	[[ -n "$*" ]] || out:fail "Did not provide a command for buffered output\n\n${OUTPUT_BUFFER_defer[*]}"

	[[ "${#OUTPUT_BUFFER_defer[@]}" -gt 1 ]] || return 0

	for buffer_line in "${OUTPUT_BUFFER_defer[@]:1}"; do
		"$@" "$buffer_line"
	done

	out:buffer_initialize
}

### out:fail [CODE] MESSAGE Usage:bbuild
# print a red failure message to stderr and exit with CODE
# CODE must be a number
# if no code is specified, error code 127 is used
###/doc
function out:fail {
	local ERCODE=127
	local numpat='^[0-9]+$'

	if [[ "$1" =~ $numpat ]]; then
		ERCODE="$1"; shift || :
	fi

	echo -e "${CBRED}ERROR FAIL: $CRED$*$CDEF" 1>&2
	exit $ERCODE
}

### out:error MESSAGE Usage:bbuild
# print a red error message to stderr
#
# unlike out:fail, does not cause script exit
###/doc
function out:error {
	echo -e "${CBRED}ERROR: ${CRED}$*$CDEF" 1>&2
}

### out:dump Usage:bbuild
#
# Dump stdin contents to console stderr. Requires debug mode.
#
# Example
#
# 	action_command 2>&1 | out:dump
#
###/doc

function out:dump {
	echo -e -n "${CBPUR}$*" 1>&2
	echo -e -n "$CPUR" 1>&2
	cat - 1>&2
	echo -e -n "$CDEF" 1>&2
}

### out:break MESSAGE Usage:bbuild
#
# Add break points to a script
#
# Requires MODE_DEBUG set to true
#
# When the script runs, the message is printed with a propmt, and execution pauses.
#
# Press return to continue execution.
#
# Type `exit`, `quit` or `stop` to stop the program. If the breakpoint is in a subshell,
#  execution from after the subshell will be resumed.
#
###/doc

function out:break {
	[[ "$MODE_DEBUG" = true ]] || return 0

	echo -en "${CRED}BREAKPOINT: $* >$CDEF " >&2
	read
	if [[ "$REPLY" =~ quit|exit|stop ]]; then
		out:fail "ABORT"
	fi
}

if [[ "$MODE_DEBUG_VERBOSE" = true ]]; then
	set -x
fi

autohelp:check "$@"

DOUPDATE=no
DEBUGMODE=no
ARGS=
ARG1=
FILTER=

while [[ -n "$@" ]]; do
	ARG=$1 ; shift
	case "$ARG" in
	-u|--update)
		DOUPDATE=yes
		;;
	--debug)
		DEBUGMODE=yes
		;;
	-f|--filter)
		FILTER="$(echo $1|sed -r "s/[\"']//g")" ; shift
		;;
	-h|--help)
		printhelp
		exit 0
		;;
	*)
		ARGS="$ARGS $ARG"
		;;
	esac
done

function firstarg { ARG1="$1" ; }
firstarg "$ARGS"

out:debug "ARG1=$ARG1"

function docpan { echo "m $ARG1" | cpan ; }

if [[ -z "$ARGS" ]]; then
	out:fail "You must supply at least one package name to search."
fi

SFILE="/tmp/searchfile_$(date "+%F%T"|md5sum|cut -d' ' -f1)"
touch "$SFILE" || out:fail "Cannot create temp file"

function searchit {
	out:info "Searching $1"
	out:debug "$@"
	local SOURCE=$1 ; shift
	echo -e "\n[1;34m\t$SOURCE\n=============[0m" >> "$SFILE"
	if [[ -n "$FILTER" ]]; then
		$@ | grep -P "$FILTER" >> "$SFILE"
	else
		$@ >> "$SFILE"
	fi
}

function doupdate {
	if [[ "$DOUPDATE" = yes ]]; then
		sudo $@
	fi
}

if [[ -f /usr/local/bin/paf ]]; then # support our own wrapper :-)
	doupdate paf -u
	searchit paf paf "$ARGS"
elif [[ -f /usr/bin/apt-cache ]]; then
	doupdate apt-get update
	searchit APT apt-cache search "$ARGS"
elif [[ -f /usr/bin/dnf ]]; then
	searchit dnf dnf search "$ARGS"
	searchit dnfgroup dnf groupsearch "$ARGS"
elif [[ -f /usr/bin/yum ]]; then
	searchit yum yum search "$ARGS"
	searchit yumgroup yum groupsearch "$ARGS"
elif [[ -f /usr/bin/zypper ]]; then
	searchit zypper zypper search "$ARGS"
elif [[ -f /usr/bin/yaourt ]]; then
	doupdate yaourt -Sy
	searchit yaourt yaourt -Qs "$ARGS"
elif [[ -f /usr/bin/pacman ]]; then
	doupdate pacman -Sy
	searchit pacman pacman -Qs "$ARGS"
elif [[ -f /usr/bin/emerge ]]; then
	doupdate emerge sync
	searchit emerge emerge -s "$ARG1"
elif [[ -f /usr/bin/tazpkg ]]; then
	doupdate tazpkg recharge
	searchit tazpkg tazpkg search "$ARG1"
fi

# do these need explicit updates?
if [[ -f /usr/bin/pip ]]; then searchit pip pip search "$ARGS" ; fi
if [[ -f /usr/bin/gem ]]; then searchit gem gem search "$ARGS" ; fi
if [[ -f /usr/bin/npm ]]; then searchit npm npm search "$ARGS" ; fi
if [[ -f /usr/bin/cpan ]]; then searchit cpan docpan ; fi
if [[ -f /usr/bin/pear ]]; then searchit pear pear search "$ARGS" ; fi

# package maangement locally

function findpkg {
	EXT=.$1 ; shift
	locate "$ARG1" | egrep "^${HOME}/.+$EXT\$"
}

function findfile {
	SIGFILE=$1 ; shift
	locate "$ARG1" | egrep "^${HOME}/.+/$SIGFILE\$"
}

if [[ -f /usr/bin/dpkg ]]; then
	searchit "Local deb files" findpkg ".deb"
elif [[ -f /usr/bin/yum ]] || [[ -f /usr/bin/dpkg ]]; then
	searchit "Local RPM files" findpkg ".rpm"
fi

# ================
# some more outlandish searches

function searchweb {
	local QUERY="$(echo $1|base64 -di)" ; shift
	local PATTERN="$(echo $1|base64 -di)" ; shift
	elinks -dump 1 "https://encrypted.google.com/search?hl=en&q=$QUERY" | grep -P "$PATTERN" -o|sort|uniq
}

if [[ -f /usr/bin/elinks ]]; then
	# ---- Github
	searchit github searchweb $(echo "github%20\"$ARG1\""|base64 -w 0) $(echo "https://github.com/[a-zA-Z0-9_.-]+/[a-zA-Z0-9._-]+"|base64 -w 0)
else
	out:warn "We need elinks for searching the web"
fi

# ===============
# Local builds

searchit "Local buildables" findpkg 'Makefile|install\.sh'

# ===========

less -R "$SFILE"
rm "$SFILE"
