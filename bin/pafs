#!/usr/bin/env bash

set -u

### pafs Usage:help
# 
# Search for packages everywhere!
# 
# (C) Tai Kedzierski, released under GPL v3
# 
# 
# 
# This script was inspired by the "Universal xkcd installer"
# 
# Rather than installing packages however, it searches a wide range of sources, including (as apporpriate):
# 
# 
# * standard repositories for apt, dnf/yum, pacman, tazpkg and emerge systems
# * AUR if yaourt is detected, in which case yaourt search is used instead of pacman
# * Where detected, cpan (this needs to have been initialized first), pear, pip, ruby gems, npm, cargo
# * searches for local .deb and .rpm files depending on detection of apt-get or yum/dnf
# * looks for directories with "Makefile" or "install.sh" files
# * and even performs a basic web search for github repositories
# 
# The results are then displayed in `less`, and you can see which repositories or locations yeilded a result.
# 
# OPTIONS
# 
# --update|-u
#     Whether to run the package list update mechanism, if appropriate
# 
# --filter|-f
#     filter results using a perl-style regular expression (`grep -P`)
# 
# --help|-h
#     Prints this help
# 
# --dump|-d
#     Dump to stdout instead of through less
#
# -e=MANAGER[,MANAGER...]
#     Package managers to exclude, e.g. `-e=docpan,docker,github`
###/doc

### Package manager shortnames Usage:help
#
# Short names for package manager exclusion:
#
#   os                    -- the operating system's package manager, such as apt, yum, pacman, etc
#   pip, gem, npm, docpan
#       pear, cargo       -- language package managers
#   local                 -- local files (.rpm, .deb, Makefile, install.sh)
#   github                -- github.com
#   docker                -- docker
#
# You can set names in your .bashrc to always ignore certain repositories, for example
#
#   export EXCLUDED_MANAGERS="docpan local docker"
#
# will cause `pafs` to never search CPAN, local files, or docker images.
#
###/doc

##bash-libs: autohelp.sh @ 266ad599 (after 1.1.4)

### autohelp:print [ SECTION [FILE] ] Usage:bbuild
# Write your help as documentation comments in your script
#
# If you need to output the help from your script, or a file, call the
# `autohelp:print` function and it will print the help documentation
# in the current script to stdout
#
# A help comment looks like this:
#
#    ### <title> Usage:help
#    #
#    # <some content>
#    #
#    # end with "###/doc" on its own line (whitespaces before
#    # and after are OK)
#    #
#    ###/doc
#
# You can set a different help section by specifying a subsection
#
# 	autohelp:print section2
#
# > This would print a section defined in this way:
#
# 	### Some title Usage:section2
# 	# <some content>
# 	###/doc
#
# You can set a different comment character by setting the 'HELPCHAR' environment variable:
#
# 	HELPCHAR=%
#
###/doc

HELPCHAR='#'

function autohelp:print {
    local SECTION_STRING="${1:-}"; shift || :
    local TARGETFILE="${1:-}"; shift || :
    [[ -n "$SECTION_STRING" ]] || SECTION_STRING=help
    [[ -n "$TARGETFILE" ]] || TARGETFILE="$0"

        echo -e "\n$(basename "$TARGETFILE")\n===\n"
        local SECSTART='^\s*'"$HELPCHAR$HELPCHAR$HELPCHAR"'\s+(.+?)\s+Usage:'"$SECTION_STRING"'\s*$'
        local SECEND='^\s*'"$HELPCHAR$HELPCHAR$HELPCHAR"'\s*/doc\s*$'
        local insec=false

        while read secline; do
                if [[ "$secline" =~ $SECSTART ]]; then
                        insec=true
                        echo -e "\n${BASH_REMATCH[1]}\n---\n"

                elif [[ "$insec" = true ]]; then
                        if [[ "$secline" =~ $SECEND ]]; then
                                insec=false
                        else
                echo "$secline" | sed -r "s/^\s*$HELPCHAR//g"
                        fi
                fi
        done < "$TARGETFILE"

        if [[ "$insec" = true ]]; then
                echo "WARNING: Non-terminated help block." 1>&2
        fi
    echo ""
}

### autohelp:paged Usage:bbuild
#
# Display the help in the pager defined in the PAGER environment variable
#
###/doc
function autohelp:paged {
    : ${PAGER=less}
    autohelp:print "$@" | $PAGER
}

### autohelp:check Usage:bbuild
#
# Automatically print help and exit if "--help" is detected in arguments
#
# Example use:
#
#    #!/bin/bash
#
#    ### Some help Usage:help
#    #
#    # Some help text
#    #
#    ###/doc
#
#    #%include autohelp.sh
#
#    main() {
#        autohelp:check "$@"
#
#        # now add your code
#    }
#
#    main "$@"
#
###/doc
autohelp:check() {
    if [[ "$*" =~ --help ]]; then
        cols="$(tput cols)"
        autohelp:print | fold -w "$cols" -s || autohelp:print
        exit 0
    fi
}
##bash-libs: out.sh @ 266ad599 (after 1.1.4)

##bash-libs: colours.sh @ 266ad599 (after 1.1.4)

### Colours for bash Usage:bbuild
# A series of colour flags for use in outputs.
#
# Example:
# 	
# 	echo -e "${CRED}Some red text ${CBBLU} some blue text $CDEF some text in the terminal's default colour")
#
# Requires processing of escape characters.
#
# Colours available:
#
# CRED, CBRED, HLRED -- red, bold red, highlight red
# CGRN, CBGRN, HLGRN -- green, bold green, highlight green
# CYEL, CBYEL, HLYEL -- yellow, bold yellow, highlight yellow
# CBLU, CBBLU, HLBLU -- blue, bold blue, highlight blue
# CPUR, CBPUR, HLPUR -- purple, bold purple, highlight purple
# CTEA, CBTEA, HLTEA -- teal, bold teal, highlight teal
#
# CDEF -- switches to the terminal default
# CUNL -- add underline
#
# Note that highlight and underline must be applied or re-applied after specifying a colour.
#
# If the session is detected as being in a pipe, colours will be turned off.
#   You can override this by calling `colours:check --color=always` at the start of your script
#
###/doc

##bash-libs: tty.sh @ 266ad599 (after 1.1.4)

tty:is_ssh() {
    [[ -n "$SSH_TTY" ]] || [[ -n "$SSH_CLIENT" ]] || [[ "$SSH_CONNECTION" ]]
}

tty:is_pipe() {
    [[ ! -t 1 ]]
}

### colours:check ARGS Usage:bbuild
#
# Check the args to see if there's a `--color=always` or `--color=never`
#   and reload the colours appropriately
#
###/doc
colours:check() {
    if [[ "$*" =~ --color=always ]]; then
        COLOURS_ON=true
    elif [[ "$*" =~ --color=never ]]; then
        COLOURS_ON=false
    fi

    colours:define
    return 0
}

colours:auto() {
    if tty:is_pipe ; then
        COLOURS_ON=false
    else
        COLOURS_ON=true
    fi

    colours:define
    return 0
}

colours:define() {
    if [[ "$COLOURS_ON" = false ]]; then

        export CRED=''
        export CGRN=''
        export CYEL=''
        export CBLU=''
        export CPUR=''
        export CTEA=''

        export CBRED=''
        export CBGRN=''
        export CBYEL=''
        export CBBLU=''
        export CBPUR=''
        export CBTEA=''

        export HLRED=''
        export HLGRN=''
        export HLYEL=''
        export HLBLU=''
        export HLPUR=''
        export HLTEA=''

        export CDEF=''

    else

        export CRED=$(echo -e "\033[0;31m")
        export CGRN=$(echo -e "\033[0;32m")
        export CYEL=$(echo -e "\033[0;33m")
        export CBLU=$(echo -e "\033[0;34m")
        export CPUR=$(echo -e "\033[0;35m")
        export CTEA=$(echo -e "\033[0;36m")

        export CBRED=$(echo -e "\033[1;31m")
        export CBGRN=$(echo -e "\033[1;32m")
        export CBYEL=$(echo -e "\033[1;33m")
        export CBBLU=$(echo -e "\033[1;34m")
        export CBPUR=$(echo -e "\033[1;35m")
        export CBTEA=$(echo -e "\033[1;36m")

        export HLRED=$(echo -e "\033[41m")
        export HLGRN=$(echo -e "\033[42m")
        export HLYEL=$(echo -e "\033[43m")
        export HLBLU=$(echo -e "\033[44m")
        export HLPUR=$(echo -e "\033[45m")
        export HLTEA=$(echo -e "\033[46m")

        export CDEF=$(echo -e "\033[0m")

    fi
}

colours:auto

### Console output handlers Usage:bbuild
#
# Write data to console stderr using colouring
#
###/doc

### out:info MESSAGE Usage:bbuild
# print a green informational message to stderr
###/doc
function out:info {
    echo "$CGRN$*$CDEF" 1>&2
}

### out:warn MESSAGE Usage:bbuild
# print a yellow warning message to stderr
###/doc
function out:warn {
    echo "${CBYEL}WARN: $CYEL$*$CDEF" 1>&2
}

### out:defer MESSAGE Usage:bbuild
# Store a message in the output buffer for later use
###/doc
function out:defer {
    OUTPUT_BUFFER_defer[${#OUTPUT_BUFFER_defer[@]}]="$*"
}

# Internal
function out:buffer_initialize {
    OUTPUT_BUFFER_defer=(:)
}
out:buffer_initialize

### out:flush HANDLER ... Usage:bbuild
#
# Pass the output buffer to the command defined by HANDLER
# and empty the buffer
#
# Examples:
#
# 	out:flush echo -e
#
# 	out:flush out:warn
#
# (escaped newlines are added in the buffer, so `-e` option is
#  needed to process the escape sequences)
#
###/doc
function out:flush {
    [[ -n "$*" ]] || out:fail "Did not provide a command for buffered output\n\n${OUTPUT_BUFFER_defer[*]}"

    [[ "${#OUTPUT_BUFFER_defer[@]}" -gt 1 ]] || return 0

    for buffer_line in "${OUTPUT_BUFFER_defer[@]:1}"; do
        "$@" "$buffer_line"
    done

    out:buffer_initialize
}

### out:fail [CODE] MESSAGE Usage:bbuild
# print a red failure message to stderr and exit with CODE
# CODE must be a number
# if no code is specified, error code 127 is used
###/doc
function out:fail {
    local ERCODE=127
    local numpat='^[0-9]+$'

    if [[ "$1" =~ $numpat ]]; then
        ERCODE="$1"; shift || :
    fi

    echo "${CBRED}ERROR FAIL: $CRED$*$CDEF" 1>&2
    exit $ERCODE
}

### out:error MESSAGE Usage:bbuild
# print a red error message to stderr
#
# unlike out:fail, does not cause script exit
###/doc
function out:error {
    echo "${CBRED}ERROR: ${CRED}$*$CDEF" 1>&2
}
#%import colour.sh

### Debug lib Usage:bbuild
#
# Debugging tools and functions.
#
# You need to activate debug mode using debug:activate command at the start of your script
#  (or from whatever point you wish it to activate)
#
###/doc

### Environment Variables Usage:bbuild
#
# DEBUG_mode : set to 'true' to enable debugging output
#
###/doc

: ${DEBUG_mode=false}

### debug:mode [output | /output | verbose | /verbose] ... Usage:bbuild
#
# Activate debug output (`output`), or activate command tracing (`verbose`)
#
# Deactivate with the corresponding `/output` and `/verbose` options
#
###/doc

function debug:mode() {
    local mode_switch
    for mode_switch in "$@"; do
        case "$mode_switch" in
        output)
            DEBUG_mode=true ;;
        /output)
            DEBUG_mode=false ;;
        verbose)
            set -x ;;
        /verbose)
            set +x ;;
        esac
    done
}

### debug:print MESSAGE Usage:bbuild
# print a blue debug message to stderr
# only prints if DEBUG_mode is set to "true"
###/doc
function debug:print {
    [[ "$DEBUG_mode" = true ]] || return 0
    echo "${CBBLU}DEBUG: $CBLU$*$CDEF" 1>&2
}

### debug:dump [MARKER] Usage:bbuild
#
# Pipe the data coming through stdin to stdout (as if it weren't there at all)
#
# If debug mode is on, *also* write the same data to stderr, each line preceded by MARKER
#
# Insert this function into pipes to see their output when in debugging mode
#
#   sed -r 's/linux|unix/*NIX/gi' myfile.txt | debug:dump | lprint
#
# Or use this to mask a command's output unless in debug mode
#
#   which binary 2>&1 | debug:dump >/dev/null
#
###/doc
function debug:dump {
    if [[ "$DEBUG_mode" = true ]]; then
        local MARKER="${1:-DEBUG: }"; shift || :

        cat - | sed -r "s/^/$MARKER/" | tee -a /dev/stderr
    else
        cat -
    fi
}

### debug:break MESSAGE Usage:bbuild
#
# Add break points to a script
#
# Requires `DEBUG_mode` set to true
#
# When the script runs, the message is printed with a propmt, and execution pauses.
#
# Press return to continue execution.
#
# Type `exit`, `quit` or `stop` to stop the program. If the breakpoint is in a subshell,
#  execution from after the subshell will be resumed.
#
###/doc

function debug:break {
    [[ "$DEBUG_mode" = true ]] || return 0

    echo -en "${CRED}BREAKPOINT: $* >$CDEF " >&2
    read
    if [[ "$REPLY" =~ quit|exit|stop ]]; then
        echo "${CBRED}ABORT${CDEF}"
    fi
}
##bash-libs: bincheck.sh @ 266ad599 (after 1.1.4)

### bincheck:get COMMANDS ... Usage:bbuild
#
# Return the first existing binary
#
# Useful for finding an appropriate binary when you know
# different systems may supply binaries under different names.
#
# Returns the full path from `which` for the first executable
# encountered.
#
# Example:
#
# 	bincheck:get markdown_py markdown ./mymarkdown
#
# Tries in turn to get a `markdown_py`, then a `markdown`, and then a local `./mymarkdown`
#
###/doc

bincheck:get() {
    local BINEXE=
    for binname in "$@"; do
        # Some implementations of `which` print error messages
        # Not useful here.
        BINEXE=$(which "$binname" 2>/dev/null)

        if [[ -n "$BINEXE" ]]; then
            echo "$BINEXE"
            return 0
        fi
    done
    return 1
}

### bincheck:has NAMES ... Usage:bbuild
#
# Determine if at least one of the binaries listed is present and installed on the system
#
###/doc

bincheck:has() {
    [[ -n "$(bincheck:get "$@")" ]]
}

### bincheck:path NAME Usage:bbuild
#
# Determine the actual path to the command
#
# Relative paths are not expanded.
#
###/doc

bincheck:path() {
    local binname="$1"; shift || :

    [[ "$binname" =~ / ]] && { 
        # A relative path cannot be resolved, just check existence
        [[ -e "$binname" ]] && echo "$binname" || return 1

    } || binname="$(which "$binname" 2>/dev/null)"

    # `which` failed
    [[ -n "$binname" ]] || return 1

    [[ -h "$binname" ]] && {

        local pointedname="$(ls -l "$binname"|grep -oP "$binname.+"|sed "s|$binname -> ||")"
        bincheck:path "$pointedname" ; return "$?"
    
    } || echo "$binname"
}

function docpan {
    echo "m $1" | cpan
}

function register_exclusions {
    local exclusion
    for exclusion in $(echo "$1"|sed 's/,/ /g'); do
        EXCLUDED_MANAGERS="$EXCLUDED_MANAGERS $exclusion"
    done
}

function searchit {
    local SOURCE="$1" ; shift

    out:info "Searching $1"
    debug:print "$*"

    echo -e "\n${CBBLU}\t$SOURCE\n=============${CDEF}" >> "$SFILE"

    "$@" | grep -P "$FILTER" >> "$SFILE"

}

function doupdate {
    if [[ "$DOUPDATE" = yes ]]; then
        sudo $@
    fi
}

function findpkg {
    EXT=".$1" ; shift
    locate "$ARG1" | egrep "^${HOME}/.+$EXT\$"
}

function findfile {
    SIGFILE="$1" ; shift
    locate "$ARG1" | egrep "^${HOME}/.+/$SIGFILE\$"
}

function is_not_excluded() {
    local exclusion
    # Deliberately not quoting, because variable cannot be an array
    for exclusion in $EXCLUDED_MANAGERS; do
        [[ "$1" != "$exclusion" ]] || return 1
    done
    return 0
}

function trypkg {
    local pkg
    bincheck:has "$@" || return 1

    for pkg in "$@"; do
        is_not_excluded "$pkg" || return 1
    done

    return 0
}

function searchweb {
    local QUERY="$1" ; shift
    local PATTERN="$1" ; shift
    elinks -dump 1 "https://encrypted.google.com/search?hl=en&q=$QUERY" | grep -P "$PATTERN" -o|sort|uniq
}

autohelp:check "$@"

DOUPDATE=no
DEBUGMODE=no
ARGS=()
ARG1=
FILTER=.
: "${EXCLUDED_MANAGERS=}"
PAFS_PAGER=(less -R)

while [[ -n "$@" ]]; do
    ARG="$1" ; shift
    case "$ARG" in
    -u|--update)
        DOUPDATE=yes
        ;;
    --debug)
        debug:mode output
        ;;
    -f|--filter)
        FILTER="$(echo $1|sed -r "s/[\"']//g")" ; shift
        ;;
    -h|--help)
        printhelp
        exit 0
        ;;
    -e=*)
        register_exclusions "${ARG#*=}"
        ;;
    --dump|-d)
        PAFS_PAGER=(cat)
        ;;
    *)
        ARGS+=("$ARG")
        ;;
    esac
done

ARG1="${ARGS[@]}"
debug:print "ARG1=$ARG1"

if [[ -z "$ARGS" ]]; then
    out:fail "You must supply at least one package name to search."
fi

#SFILE="/tmp/searchfile_$(date "+%F%T"|md5sum|cut -d' ' -f1)"
SFILE="$(mktemp)" || out:fail "Cannot create temp file"

if is_not_excluded os; then
    if trypkg paf; then # support our own wrapper :-)
        doupdate paf -u
        searchit paf paf "$ARGS"

    elif trypkg apt-cache; then
        doupdate apt-get update
        searchit APT apt-cache search "$ARGS"

    elif trypkg dnf; then
        searchit dnf dnf search "$ARGS"
        searchit dnfgroup dnf groupsearch "$ARGS"

    elif trypkg yum; then
        searchit yum yum search "$ARGS"
        searchit yumgroup yum groupsearch "$ARGS"

    elif trypkg zypper; then
        searchit zypper zypper search "$ARGS"

    elif trypkg yaourt; then
        doupdate yaourt -Sy
        searchit yaourt yaourt -Qs "$ARGS"

    elif trypkg pacman; then
        doupdate pacman -Sy
        searchit pacman pacman -Qs "$ARGS"

    elif trypkg emerge; then
        doupdate emerge sync
        searchit emerge emerge -s "$ARG1"

    elif trypkg tazpkg; then
        doupdate tazpkg recharge
        searchit tazpkg tazpkg search "$ARG1"
    fi
fi

# do these need explicit updates?
trypkg pip && searchit pip pip search "$ARGS"
trypkg gem && searchit gem gem search "$ARGS"
trypkg npm && searchit npm npm search "$ARGS"
trypkg docpan && searchit cpan docpan "$ARG1"
trypkg pear && searchit pear pear search "$ARGS"
trypkg cargo && searchit cargo cargo search "$ARGS"

# ================
# some more outlandish searches

if trypkg docker; then
    searchit Docker docker search "$ARG1"
fi

if bincheck:has elinks; then
    URLARG1="$(python -c "import urllib as u; print(u.quote('$ARG1'))")"
    # ---- Github
    is_not_excluded github && \
        searchit github searchweb "github%20$URLARG1" "https://github.com/[a-zA-Z0-9_.-]+/[a-zA-Z0-9._-]+"
else
    out:warn "'elinks' is required for searching the web"
fi

# ===============
# Local builds
if is_not_excluded local; then
    searchit "Local buildables" findpkg 'Makefile|install\.sh'

    # package maangement locally

    if trypkg dpkg yum dnf; then
        searchit "Local RPM files" findpkg ".rpm"

    elif trypkg dpkg; then
        searchit "Local deb files" findpkg ".deb"
    fi
fi

# ===========

"${PAFS_PAGER[@]}" "$SFILE"
rm "$SFILE"
