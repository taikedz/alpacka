#!/bin/bash

### alp Usage:help
#
# The `alp` command
# Cross-distro wrapper to give a standardized command
# line utility for searching a number of repositories.
#
# (C) 2017 Tai Kedzierski
# Released under GPLv3
#
# ---------------------------------------------------
#
# (Default)
# Without any switches or options, alp searches packages and
# displays the result in the standard pager in PAGER. If no
# page is specified, uses less. If less is not installed or
# the -O option is supplied, then dumps to stdout.
#
# Where multiple terms are specified, results returned
# depend on how the package manager handles this:
#
# 	apt-get : looks for all terms in the name and description
# 	yum/dnf : looks for all terms in the name and description
# 	tazpkg  : search for the first term, and filter on the remainder
# 	pacman  : (tbd)
# 	zypper  : (tbd)
#
#
# Standard commands
# -----------------
#
# If several of these command switches are specified, only the last one
# will be applied.
#
# -s|--show PACKAGE
# 	Show the information for a single package
#
# -l |--list
# 	List the installed packages
#
# -i|--install PACKAGES ...
# 	Install the specified packages.
#
# 	If an operation is currently underway, the packages are added
# 	to a waiting list.
#
# -g|--upgrade [PACKAGES ...]
# 	Upgrade the specified packages.
#
# 	If no packages are specified, updates all packages.
#
# 	If an operation is currently underway, the action is queued
#
# -a|--add-repository
# 	Add a repository in systems which allow it (yum/dnf and apt supported)
#
#
# Additional commands
# -------------------
#
# -u|--update
# 	Update the local cache before running the main command.
# 	Does not apply to yum/dnf
#
# -c|--clean
# 	Cleans the cache of packages (apt only?)
#
# -O|--stdout
# 	Forcibly dump to stdout
#
# 	You can specify a custom pager by setting the
# 	PAGER environment variable.
#
#
# Additional Package Management Systems
# =====================================
#
# It is possible to specify other repositories to search on top of the
# main distro repositories. 
#
# -D|--no-distro-package-manager
# 	Switch off search on the default package manager
#
# To specify other package managers to search, populate a colon-
# separated list from the following list into ALPACKAS
#
# * cpan -- search Perl's CPAN packages
# * pip -- search Python's pip packages
# * compose -- search PHP's Composer packages
# * gem -- seach Ruby's Gems
# * node -- search Nod.js's packages
# * aur -- use the Arch User Repository
#
# For example, to search for a markdown package in pip and node, and
# not in the distro's normal package manager:
#
# 	ALPACKAS=pip:node alp -D markdown
#
# Only search, show and install actions are guaranteed to work for
# additional package management systems.
#
###/doc
#!/bin/bash

### printhelp Usage:bbuild
# Write your help as documentation comments in your script
#
# If you need to output the help from a running script, call the
# `printhelp` function and it will print the help documentation
# in the current script to stdout
#
# A help comment looks like this:
#
#	### <title> Usage:help
#	#
#	# <some content>
#	#
#	# end with "###/doc" on its own line (whitespaces before
#	# and after are OK)
#	#
#	###/doc
#
###/doc

CHAR='#'

function printhelp {
	local USAGESTRING=help
	local TARGETFILE=$0
	if [[ -n "$*" ]]; then USAGESTRING="$1" ; shift; fi
	if [[ -n "$*" ]]; then TARGETFILE="$1" ; shift; fi

        echo -e "\n$(basename "$TARGETFILE")\n===\n"
        local SECSTART='^\s*'"$CHAR$CHAR$CHAR"'\s+(.+?)\s+Usage:'"$USAGESTRING"'\s*$'
        local SECEND='^\s*'"$CHAR$CHAR$CHAR"'\s*/doc\s*$'
        local insec="$(mktemp --tmpdir)"; rm "$insec"
        cat "$TARGETFILE" | while read secline; do
                if [[ "$secline" =~ $SECSTART ]]; then
                        touch "$insec"
                        echo -e "\n${BASH_REMATCH[1]}\n---\n"
                elif [[ -f $insec ]]; then
                        if [[ "$secline" =~ $SECEND ]]; then
                                rm "$insec"
                        else
				echo "$secline" | sed -r "s/^\s*$CHAR//g"
                        fi
                fi
        done
        if [[ -f "$insec" ]]; then
                echo "WARNING: Non-terminated help block." 1>&2
		rm "$insec"
        fi
	echo ""
}

### automatic help Usage:main
#
# automatically call help if "--help" is detected in arguments
#
###/doc
if [[ "$@" =~ --help ]]; then
	printhelp
	exit 0
fi
#!/bin/bash

#!/bin/bash

### Colours for bash Usage:bbuild
# A series of colour flags for use in outputs.
#
# Example:
# 	
# 	echo "${CRED}Some red text ${CBBLU} some blue text $CDEF some text in the terminal's default colour"
#
# Colours available:
#
# CDEF -- switches to the terminal default
#
# CRED, CBRED -- red and bright/bold red
# CGRN, CBGRN -- green and bright/bold green
# CYEL, CBYEL -- yellow and bright/bold yellow
# CBLU, CBBLU -- blue and bright/bold blue
# CPUR, CBPUR -- purple and bright/bold purple
#
###/doc

export CDEF="[0m"
export CRED="[31m"
export CGRN="[32m"
export CYEL="[33m"
export CBLU="[34m"
export CPUR="[35m"
export CBRED="[1;31m"
export CBGRN="[1;32m"
export CBYEL="[1;33m"
export CBBLU="[1;34m"
export CBPUR="[1;35m"

MODE_DEBUG=no

### debuge MESSAGE Usage:bbuild
# print a blue debug message to stderr
# only prints if MODE_DEBUG is set to "yes"
###/doc
function debuge {
	if [[ "$MODE_DEBUG" = yes ]]; then
		echo -e "${CBBLU}DEBUG:$CBLU$*$CDEF" 1>&2
	fi
}

### infoe MESSAGE Usage:bbuild
# print a green informational message to stderr
###/doc
function infoe {
	echo -e "$CGRN$*$CDEF" 1>&2
}

### warne MESSAGE Usage:bbuild
# print a yellow warning message to stderr
###/doc
function warne {
	echo -e "${CBYEL}WARN:$CYEL $*$CDEF" 1>&2
}

### faile [CODE] MESSAGE Usage:bbuild
# print a red failure message to stderr and exit with CODE
# CODE must be a number
# if no code is specified, error code 127 is used
###/doc
function faile {
	local ERCODE=127
	local numpat='^[0-9]+$'

	if [[ "$1" =~ $numpat ]]; then
		ERCODE="$1"; shift
	fi

	echo "${CBRED}ERROR FAIL:$CRED$*$CDEF" 1>&2
	exit $ERCODE
}

function dumpe {
	echo -n "[1;35m$*" 1>&2
	echo -n "[0;35m" 1>&2
	cat - 1>&2
	echo -n "[0m" 1>&2
}

function breake {
	if [[ "$MODE_DEBUG" != yes ]]; then
		return
	fi

	read -p "${CRED}BREAKPOINT: $* >$CDEF " >&2
	if [[ "$REPLY" =~ $(echo 'quit|exit|stop') ]]; then
		faile "ABORT"
	fi
}

### Auto debug Usage:main
# When included, bashout processes a special "--debug" flag
#
# It does not remove the debug flag from arguments.
###/doc

if [[ "$*" =~ --debug ]]; then
	MODE_DEBUG=yes
fi

#!/bin/bash

#!/bin/bash

### A more usable arguments manipulator Usage:bbuild
#
# Pass arguments into a newline-delimited variable for easier processing
#
# args_store ARGS ...
#
# 	Echoes each argument on its own line; this echoed string is an ARGSTRING
#
# args_get ARGSTRING PAT [ N ]
#
# 	Prints any line in ARGSTRING that matches PAT at the start
#
# 	If N is specified as an integer, prints that many subsequent tokens
#
# args_remove ARGSTRING PAT [ N ]
#
# 	Remove any lines in the arguments string matchinig PAT at their start
#
# 	If N is specified as an integer, removes that many subsequent tokens
#
# EXAMPLE
# =======
#
#
# 	myargs=$(args_store "$@")
#
# 	# Use a dollar sign to terminate the pattern
# 	files="$(args_get "$myargs" -f$ 1)"
#
# 	# Take away the arguments we have already extracted
# 	# and store them in the old variable
# 	myargs="$(args_remove "$myargs" -f$ 1)"
#
###/doc

function args_store {
	local argstring=

	for a in "$@"; do
		argstring="$argstring$(echo -e "\n${a}")"
	done
	echo "$argstring"|tail -n +2
}

function args_get {
	local argstring="$1"; shift
	local pat="$1"; shift
	local next=
	if [[ -n "$*" ]]; then next="$1"; shift; fi
	local tokensplus=0

	if [[ -z "$next" ]]; then
		next=0
	elif [[ ! "$next" =~ $(echo '^[0-9]+$') ]]; then
		faile "Invalid arg context count"
	fi

	echo "$argstring"|while read arg; do
		if [[ "$arg" =~ ^$pat ]]; then
			echo "$arg"
			if [[ "$next" -gt 0 ]]; then
				tokensplus="$next"
			fi

		elif [[ "$tokensplus" -gt 0 ]]; then
			echo "$arg"
			tokensplus=$(( $tokensplus - 1 ))
		fi
	done
}

function args_remove {
	local argstring="$1"; shift
	local pat="$1"; shift
	local next=
	if [[ -n "$*" ]]; then next="$1"; shift; fi
	local tokensplus=0

	if [[ -z "$pat" ]]; then
		# return idem
		echo "$argstring"
		return
	fi

	if [[ -z "$next" ]]; then
		next=0
	elif [[ ! "$next" =~ $(echo '^[0-9]+$') ]]; then
		faile "Invalid arg context count"
	fi

	echo "$argstring"|while read arg; do
		if [[ "$arg" =~ ^$pat ]]; then
			if [[ "$next" -gt 0 ]]; then
				tokensplus="$next"
			fi

		elif [[ "$tokensplus" -gt 0 ]]; then
			tokensplus=$(( $tokensplus - 1 ))
		else
			echo "$arg"
		fi
	done
}

allargs="$(args_store "$@")"

function get_main_action {
	ALPACTION="$(args_get "$allargs" "(-l|--list|-s|--show|-i|--install|-g|--upgrade)"|echo search)"
	ALPACTION="$(args_getlast "$ALPACTION")"

	if [[ "$ALPACTION" != "search" ]]; then
		debuge "Determine action from $ALPACTION"
		case "$action" in
			-l|--list)
				ALPACTION=list
				;;
			-s|--show)
				ALPACTION=show
				;;
			-i|--install)
				ALPACTION=install
				;;
			-g|--upgrade)
				ALPACTION=upgrade
				;;
		esac
	fi

	debuge "Action is $ALPACTION"
}

function get_options_list {
	ALPOPTIONS=":"

	for option in "$@"
	do
		if [[ "$option" =~ $(echo "^-u|--update|-c|--clean|-O|--stdout$") ]]; then
			debuge "Processing option candidate $option"
			case "$option" in
				-u|--update)
					ALPOPTIONS="${ALPOPTIONS}update:"
					;;
				-c|--clean)
					ALPOPTIONS="${ALPOPTIONS}clean:"
					;;
				-O|--stdout)
					ALPOPTIONS="${ALPOPTIONS}stdout:"
					;;
			esac
		fi
	done

	#echo "$ALPOPTIONS"
}

function has_option {
	if [[ ":$ALPOPTIONS:" =~ "$1" ]]; then
		debuge "$1 in $ALPOPTIONS"
		return 0
	fi
	debuge "$1 not in $ALPOPTIONS"
	return 1
}

function get_all_terms { # FIXME defining all terms as an array might be hard - damn bash
	declare -a ALPTERMS
	debuge processing "$*" into "$ALPTERMS"

	for term in "$@"
	do
		if [[ "$term" =~ $(echo "^-") ]]; then
			debuge "Discard $term"
			continue
		fi

		ALPTERMS="$ALPTERMS $term"
	done

	echo "$ALPTERMS"
}
#!/bin/bash

function do_clean {
}

set -u

#ALPACTION=$(get_main_action "$@")
#ALPOPTIONS=$(get_options_list "$@")
#ALPTERMS=$(get_all_terms "$@")
get_main_action "$@"
get_options_list "$@"
get_all_terms "$@"

if [[ -z "${ALPACKAS+x}" ]]; then
	ALPACKAS=
fi
