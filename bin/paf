#!/usr/bin/env bash

set -euo pipefail

PAF_version="2.2"
PAF_copyright="(C) Tai Kedzierski, conveyed under GPLv3"

PAF_configdir="/etc/alpacka"

### Alpacka: Uniform Package Management Wrapper Usage:help
# 
# The `paf` command is a shorthand to allow use of a single package management command across distros.
#
# Whether you are runing Ubuntu, Fedora, Arch or other, these commands will all work, and perform the equivalent expected actions.
#
# ACTIVITIES AND OPTIONS
# ----------------------
#
# Some package managers support independent activites to run before and after main actions.
#
#     -u
#         update the package database
#
#     -c
#         clean up interim packages and cache
#
#     -y
#         assume yes
#
# ACTIONS
# -------
#
# Only one action can be run at a time. The last one specified will be run. For example
#
#   paf -s htop
#
# would show info for htop, whereas
#
#   paf -s htop -i
#
# would install it.
#
#
#
# Search for keywords:
#
#    paf [-z] KEYWORDS ...
#
# Show info on each package
#
#    paf -s PACKAGES ...
#
# Install
#
#    paf -i PACKAGES ...
#
# Remove
#     
#     paf -r PACKAGES ...
#
#
#
#
# Examples
# --------
#
# Install 3 packages, after updating the package index if applicable:
#
#   paf -u -i htop vim tmux
#
# Perform a system upgrade, after upgrading the package index (if applicable):
#
#   paf -u -g
#
# Clean out package manager cache:
#
#   paf -c
#
###/doc

### Alpacka Usage:help
#
# (C) Tai Kedzierski
# https://github.com/taikedz/alpacka
#
# Provided under the terms of the GPL v3
# (GNU General Public Licesne version 3)
###/doc


##bash-libs: tty.sh @ 6421286a (2.0.1)

tty:is_ssh() {
    [[ -n "$SSH_TTY" ]] || [[ -n "$SSH_CLIENT" ]] || [[ "$SSH_CONNECTION" ]]
}

tty:is_pipe() {
    [[ ! -t 1 ]]
}

##bash-libs: colours.sh @ 6421286a (2.0.1)

### Colours for terminal Usage:bbuild
# A series of shorthand colour flags for use in outputs, and functions to set your own flags.
#
# Not all terminals support all colours or modifiers.
#
# Example:
# 	
# 	echo "${CRED}Some red text ${CBBLU} some blue text. $CDEF Some text in the terminal's default colour")
#
# Preconfigured colours available:
#
# CRED, CBRED, HLRED -- red, bright red, highlight red
# CGRN, CBGRN, HLGRN -- green, bright green, highlight green
# CYEL, CBYEL, HLYEL -- yellow, bright yellow, highlight yellow
# CBLU, CBBLU, HLBLU -- blue, bright blue, highlight blue
# CPUR, CBPUR, HLPUR -- purple, bright purple, highlight purple
# CTEA, CBTEA, HLTEA -- teal, bright teal, highlight teal
# CBLA, CBBLA, HLBLA -- black, bright red, highlight red
# CWHI, CBWHI, HLWHI -- white, bright red, highlight red
#
# Modifiers available:
#
# CBON - activate bright
# CDON - activate dim
# ULON - activate underline
# RVON - activate reverse (switch foreground and background)
# SKON - activate strikethrough
# 
# Resets available:
#
# CNORM -- turn off bright or dim, without affecting other modifiers
# ULOFF -- turn off highlighting
# RVOFF -- turn off inverse
# SKOFF -- turn off strikethrough
# HLOFF -- turn off highlight
#
# CDEF -- turn off all colours and modifiers(switches to the terminal default)
#
# Note that highlight and underline must be applied or re-applied after specifying a colour.
#
# If the session is detected as being in a pipe, colours will be turned off.
#   You can override this by calling `colours:check --color=always` at the start of your script
#
###/doc

### colours:check ARGS ... Usage:bbuild
#
# Check the args to see if there's a `--color=always` or `--color=never`
#   and reload the colours appropriately
#
#   main() {
#       colours:check "$@"
#
#       echo "${CGRN}Green only in tty or if --colours=always !${CDEF}"
#   }
#
#   main "$@"
#
###/doc
colours:check() {
    if [[ "$*" =~ --color=always ]]; then
        COLOURS_ON=true
    elif [[ "$*" =~ --color=never ]]; then
        COLOURS_ON=false
    fi

    colours:define
    return 0
}

### colours:set CODE Usage:bbuild
# Set an explicit colour code - e.g.
#
#   echo "$(colours:set "33;2")Dim yellow text${CDEF}"
#
# See SGR Colours definitions
#   <https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_(Select_Graphic_Rendition)_parameters>
###/doc
colours:set() {
    # We use `echo -e` here rather than directly embedding a binary character
    if [[ "$COLOURS_ON" = false ]]; then
        return 0
    else
        echo -e "\033[${1}m"
    fi
}

colours:define() {

    # Shorthand colours

    export CBLA="$(colours:set "30")"
    export CRED="$(colours:set "31")"
    export CGRN="$(colours:set "32")"
    export CYEL="$(colours:set "33")"
    export CBLU="$(colours:set "34")"
    export CPUR="$(colours:set "35")"
    export CTEA="$(colours:set "36")"
    export CWHI="$(colours:set "37")"

    export CBBLA="$(colours:set "1;30")"
    export CBRED="$(colours:set "1;31")"
    export CBGRN="$(colours:set "1;32")"
    export CBYEL="$(colours:set "1;33")"
    export CBBLU="$(colours:set "1;34")"
    export CBPUR="$(colours:set "1;35")"
    export CBTEA="$(colours:set "1;36")"
    export CBWHI="$(colours:set "1;37")"

    export HLBLA="$(colours:set "40")"
    export HLRED="$(colours:set "41")"
    export HLGRN="$(colours:set "42")"
    export HLYEL="$(colours:set "43")"
    export HLBLU="$(colours:set "44")"
    export HLPUR="$(colours:set "45")"
    export HLTEA="$(colours:set "46")"
    export HLWHI="$(colours:set "47")"

    # Modifiers
    
    export CBON="$(colours:set "1")"
    export CDON="$(colours:set "2")"
    export ULON="$(colours:set "4")"
    export RVON="$(colours:set "7")"
    export SKON="$(colours:set "9")"

    # Resets

    export CBNRM="$(colours:set "22")"
    export HLOFF="$(colours:set "49")"
    export ULOFF="$(colours:set "24")"
    export RVOFF="$(colours:set "27")"
    export SKOFF="$(colours:set "29")"

    export CDEF="$(colours:set "0")"

}

colours:auto() {
    if tty:is_pipe ; then
        COLOURS_ON=false
    else
        COLOURS_ON=true
    fi

    colours:define
    return 0
}

colours:auto

##bash-libs: out.sh @ 6421286a (2.0.1)

### Console output handlers Usage:bbuild
#
# Write data to console stderr using colouring
#
###/doc

### out:info MESSAGE Usage:bbuild
# print a green informational message to stderr
###/doc
function out:info {
    echo "$CGRN$*$CDEF" 1>&2
}

### out:warn MESSAGE Usage:bbuild
# print a yellow warning message to stderr
###/doc
function out:warn {
    echo "${CBYEL}WARN: $CYEL$*$CDEF" 1>&2
}

### out:defer MESSAGE Usage:bbuild
# Store a message in the output buffer for later use
###/doc
function out:defer {
    OUTPUT_BUFFER_defer[${#OUTPUT_BUFFER_defer[@]}]="$*"
}

# Internal
function out:buffer_initialize {
    OUTPUT_BUFFER_defer=(:)
}
out:buffer_initialize

### out:flush HANDLER ... Usage:bbuild
#
# Pass the output buffer to the command defined by HANDLER
# and empty the buffer
#
# Examples:
#
# 	out:flush echo -e
#
# 	out:flush out:warn
#
# (escaped newlines are added in the buffer, so `-e` option is
#  needed to process the escape sequences)
#
###/doc
function out:flush {
    [[ -n "$*" ]] || out:fail "Did not provide a command for buffered output\n\n${OUTPUT_BUFFER_defer[*]}"

    [[ "${#OUTPUT_BUFFER_defer[@]}" -gt 1 ]] || return 0

    for buffer_line in "${OUTPUT_BUFFER_defer[@]:1}"; do
        "$@" "$buffer_line"
    done

    out:buffer_initialize
}

### out:fail [CODE] MESSAGE Usage:bbuild
# print a red failure message to stderr and exit with CODE
# CODE must be a number
# if no code is specified, error code 127 is used
###/doc
function out:fail {
    local ERCODE=127
    local numpat='^[0-9]+$'

    if [[ "$1" =~ $numpat ]]; then
        ERCODE="$1"; shift || :
    fi

    echo "${CBRED}ERROR FAIL: $CRED$*$CDEF" 1>&2
    exit $ERCODE
}

### out:error MESSAGE Usage:bbuild
# print a red error message to stderr
#
# unlike out:fail, does not cause script exit
###/doc
function out:error {
    echo "${CBRED}ERROR: ${CRED}$*$CDEF" 1>&2
}
##bash-libs: syntax-extensions.sh @ 6421286a (2.0.1)

### Syntax Extensions Usage:syntax
#
# Syntax extensions for bash-builder.
#
# You will need to import this library if you use Bash Builder's extended syntax macros.
#
# You should not however use the functions directly, but the extended syntax instead.
#
##/doc

### syntax-extensions:use FUNCNAME ARGNAMES ... Usage:syntax
#
# Consume arguments into named global variables.
#
# If not enough argument values are found, the first named variable that failed to be assigned is printed as error
#
# ARGNAMES prefixed with '?' do not trigger an error
#
# Example:
#
#   #%include out.sh
#   #%include syntax-extensions.sh
#
#   get_parameters() {
#       . <(syntax-extensions:use get_parameters INFILE OUTFILE ?comment)
#
#       [[ -f "$INFILE" ]]  || out:fail "Input file '$INFILE' does not exist"
#       [[ -f "$OUTFILE" ]] || out:fail "Output file '$OUTFILE' does not exist"
#
#       [[ -z "$comment" ]] || echo "Note: $comment"
#   }
#
#   main() {
#       get_parameters "$@"
#
#       echo "$INFILE will be converted to $OUTFILE"
#   }
#
#   main "$@"
#
###/doc
syntax-extensions:use() {
    local argname arglist undef_f dec_scope argidx argone failmsg pos_ok
    
    dec_scope=""
    [[ "${SYNTAXLIB_scope:-}" = local ]] || dec_scope=g
    arglist=(:)
    argone=\"\${1:-}\"
    pos_ok=true
    
    for argname in "$@"; do
        [[ "$argname" != -- ]] || break
        [[ "$argname" =~ ^(\?|\*)?[0-9a-zA-Z_]+$ ]] || out:fail "Internal: Not a valid argument name '$argname'"

        arglist+=("$argname")
    done

    argidx=1
    while [[ "$argidx" -lt "${#arglist[@]}" ]]; do
        argname="${arglist[$argidx]}"
        failmsg="\"Internal : could not get '$argname' in function arguments\""
        posfailmsg="Internal: positional argument '$argname' encountered after optional argument(s)"

        if [[ "$argname" =~ ^\? ]]; then
            echo "$SYNTAXLIB_scope ${argname:1}=$argone; shift || :"
            pos_ok=false

        elif [[ "$argname" =~ ^\* ]]; then
            [[ "$pos_ok" != false ]] || out:fail "$posfailmsg"
            echo "declare -n${dec_scope} ${argname:1}=$argone; shift || out:fail $failmsg"

        else
            [[ "$pos_ok" != false ]] || out:fail "$posfailmsg"
            echo "$SYNTAXLIB_scope ${argname}=$argone; shift || out:fail $failmsg"
        fi

        argidx=$((argidx + 1))
    done
}


### syntax-extensions:use:local FUNCNAME ARGNAMES ... Usage:syntax
# 
# Enables syntax macro: function signatures
#   e.g. $%function func(var1 var2) { ... }
#
# Build with bbuild to leverage this function's use:
#
#   #%include out.sh
#   #%include syntax-extensions.sh
#
#   $%function person(name email) {
#       echo "$name <$email>"
#
#       # $1 and $2 have been consumed into $name and $email
#       # The rest remains available in $* :
#       
#       echo "Additional notes: $*"
#   }
#
#   person "Jo Smith" "jsmith@example.com" Some details
#
###/doc
syntax-extensions:use:local() {
    SYNTAXLIB_scope=local syntax-extensions:use "$@"
}

args:use:local() {
    syntax-extensions:use:local "$@"
}

##bash-libs: autohelp.sh @ 6421286a (2.0.1)

### Autohelp Usage:bbuild
#
# Autohelp provides some simple facilities for defining help as comments in your code.
# It provides several functions for printing specially formatted comment sections.
#
# Write your help as documentation comments in your script
#
# To output a named section from your script, or a file, call the
# `autohelp:print` function and it will print the help documentation
# in the current script, or specified file, to stdout
#
# A help comment looks like this:
#
#    ### <title> Usage:help
#    #
#    # <some content>
#    #
#    # end with "###/doc" on its own line (whitespaces before
#    # and after are OK)
#    #
#    ###/doc
#
# It can then be printed from the same script by simply calling
#
#   autohelp:print
#
# You can print a different section by specifying a different name
#
# 	autohelp:print section2
#
# > This would print a section defined in this way:
#
# 	### Some title Usage:section2
# 	# <some content>
# 	###/doc
#
# You can set a different comment character by setting the 'HELPCHAR' environment variable.
# Typically, you might want to print comments you set in a INI config file, for example
#
# 	HELPCHAR=";" autohelp:print help config-file.ini
# 
# Which would then find comments defined like this in `config-file.ini`:
#
#   ;;; Main config Usage:help
#   ; Help comments in a config file
#   ; may start with a different comment character
#   ;;;/doc
#
#
#
# Example usage in a multi-function script:
#
#   #!usr/bin/env bash
#
#   ### Main help Usage:help
#   # The main help
#   ###/doc
#
#   ### Feature One Usage:feature_1
#   # Help text for the first feature
#   ###/doc
#
#   feature1() {
#       autohelp:check:section feature_1 "$@"
#       echo "Feature I"
#   }
#
#   ### Feature Two Usage:feature_2
#   # Help text for the second feature
#   ###/doc
#
#   feature2() {
#       autohelp:check:section feature_2 "$@"
#       echo "Feature II"
#   }
#
#   main() {
#       case "$1" in
#       feature1|feature2)
#           "$1" "$@"            # Pass the global script arguments through
#           ;;
#       *)
#           autohelp:check-no-null "$@"  # Check if main help was asked for, if so, or if no args, exit with help
#
#           # Main help not requested, return error
#           echo "Unknown feature"
#           exit 1
#           ;;
#       esac
#   }
#
#   main "$@"
#
###/doc

### autohelp:print [ SECTION [FILE] ] Usage:bbuild
# Print the specified section, in the specified file.
#
# If no file is specified, prints for current script file.
# If no section is specified, defaults to "help"
###/doc

HELPCHAR='#'

autohelp:print() {
    local input_line
    local section_string="${1:-}"; shift || :
    local target_file="${1:-}"; shift || :
    [[ -n "$section_string" ]] || section_string=help
    [[ -n "$target_file" ]] || target_file="$0"

    local sec_start='^\s*'"$HELPCHAR$HELPCHAR$HELPCHAR"'\s+(.+?)\s+Usage:'"$section_string"'\s*$'
    local sec_end='^\s*'"$HELPCHAR$HELPCHAR$HELPCHAR"'\s*/doc\s*$'
    local in_section=false

    while read input_line; do
        if [[ "$input_line" =~ $sec_start ]]; then
            in_section=true
            echo -e "\n${BASH_REMATCH[1]}\n======="

        elif [[ "$in_section" = true ]]; then
            if [[ "$input_line" =~ $sec_end ]]; then
                in_section=false
            else
                echo "$input_line" | sed -r "s/^\s*$HELPCHAR/ /;s/^  (\S)/\1/"
            fi
        fi
    done < "$target_file"

    if [[ "$in_section" = true ]]; then
            out:fail "Non-terminated help block."
    fi
}

### autohelp:paged Usage:bbuild
#
# Display the help in the pager defined in the PAGER environment variable
#
###/doc
autohelp:paged() {
    : ${PAGER=less}
    autohelp:print "$@" | $PAGER
}

### autohelp:check-or-null ARGS ... Usage:bbuild
# Print help if arguments are empty, or if arguments contain a '--help' token
#
###/doc
autohelp:check-or-null() {
    if [[ -z "$*" ]]; then
        autohelp:print help "$0"
        exit 0
    else
        autohelp:check:section "help" "$@"
    fi
}

### autohelp:check-or-null:section SECTION ARGS ... Usage:bbuild
# Print help section SECTION if arguments are empty, or if arguments contain a '--help' token
#
###/doc
autohelp:check-or-null:section() {
    . <(args:use:local section -- "$@") ; 
    if [[ -z "$*" ]]; then
        autohelp:print "$section" "$0"
        exit 0
    else
        autohelp:check:section "$section" "$@"
    fi
}

### autohelp:check ARGS ... Usage:bbuild
#
# Automatically print "help" sections and exit, if "--help" is detected in arguments
#
###/doc
autohelp:check() {
    autohelp:check:section "help" "$@"
}

### autohelp:check:section SECTION ARGS ... Usage:bbuild
# Automatically print documentation for named section and exit, if "--help" is detected in arguments
#
###/doc
autohelp:check:section() {
    local section arg
    section="${1:-}"; shift || out:fail "No help section specified"

    for arg in "$@"; do
        if [[ "$arg" =~ --help ]]; then
            cols="$(tput cols)"
            autohelp:print "$section" | fold -w "$cols" -s || autohelp:print "$section"
            exit 0
        fi
    done
}

##bash-libs: askuser.sh @ 6421286a (2.0.1)

### askuser Usage:bbuild
# Present the user with questions on stderr
###/doc

yespat='^(yes|YES|y|Y)$'
numpat='^[0-9]+$'
rangepat='[0-9]+,[0-9]+'
listpat='^[0-9 ]+$'
blankpat='^ *$'

### askuser:confirm Usage:bbuild
# Ask the user to confirm a closed question. Defaults to no
#
# returns 0 on successfully match 'y' or 'yes'
# returns 1 otherwise
###/doc
function askuser:confirm {
    read -p "$* [y/N] > " 1>&2
    if [[ "$REPLY" =~ $yespat ]]; then
        return 0
    else
        return 1
    fi
}

### askuser:ask Usage:bbuild
# Ask the user to provide some text
#
# Echoes out the entered text
###/doc
function askuser:ask {
    read -p "$* : " 1>&2
    echo "$REPLY"
}

### askuser:password Usage:bbuild
# Ask the user to enter a password (does not echo what is typed)
#
# Echoes out the entered text
###/doc
function askuser:password {
    read -s -p "$* : " 1>&2
    echo >&2
    echo "$REPLY"
}

### askuser:choose_multi Usage:bbuild
# Allows the user to choose from multiple choices
#
# askuser:chose_multi MESG CHOICESTRING
#
#
# MESG is a single string token that will be displayed as prompt
#
# CHOICESTRING is a comma-separated, or newline separated, or "\\n"-separated token string
#
# Equivalent strings include:
#
# * `"a\\nb\\nc"` - quoted and explicit newline escapes
# * `"a,b,c"` - quoted and separated with commas
# * `a , b , c` - not quoted, separated by commas
# * `a`, `b` and `c` on their own lines
#
# User input:
#
# User can choose by selecting
#
# * a single item by number
# * a range of numbers (4,7 for range 4 to 7)
# * or a string that matches the pattern
#
# All option lines that match will be returned, one per line
#
# If the user selects nothing, then function returns 1 and an empty stdout
###/doc
function askuser:choose_multi {
    local mesg=$1; shift || :
    local choices=$(echo "$*"|sed -r 's/ *, */\n/g')

    out:info "$mesg:" 
    local choicelist="$(echo -e "$choices"|grep -E '^' -n| sed 's/:/: /')"
    echo "$choicelist" 1>&2
    
    local sel=$(askuser:ask "Choice")
    if [[ "$sel" =~ $blankpat ]]; then
        return 1

    elif [[ "$sel" =~ $numpat ]] || [[ "$sel" =~ $rangepat ]]; then
        echo -e "$choices" | sed -n "$sel p"
    
    elif [[ "$sel" =~ $listpat ]]; then
        echo "$choicelist" | grep -E "^${sel// /|}:" | sed -r 's/^[0-9]+: //'

    else
        echo -e "$choices"  |grep -E "$(echo "$sel"|tr " " '|')"
    fi
    return 0
}

### askuser:choose Usage:bbuild
# Ask the user to choose an item
#
# Like askuser:choose_multi, but will loop if the user selects more than one item
#
# If the user provides no entry, returns 1
#
# If the user chooses one item, that item is echoed to stdout
###/doc
function askuser:choose {
    local mesg=$1; shift || :
    while true; do
        local thechoice="$(askuser:choose_multi "$mesg" "$*")"
        local lines=$(echo -n "$thechoice" | grep '$' -c)
        if [[ $lines = 1 ]]; then
            echo "$thechoice"
            return 0
        elif [[ $lines = 0 ]]; then
            return 1
        else
            out:warn "Too many results"
        fi
    done
}
##bash-libs: bincheck.sh @ 6421286a (2.0.1)

### bincheck:get COMMANDS ... Usage:bbuild
#
# Return the first existing binary
#
# Useful for finding an appropriate binary when you know
# different systems may supply binaries under different names.
#
# Returns the full path from `which` for the first executable
# encountered.
#
# Example:
#
# 	bincheck:get markdown_py markdown ./mymarkdown
#
# Tries in turn to get a `markdown_py`, then a `markdown`, and then a local `./mymarkdown`
#
###/doc

bincheck:get() {
    local BINEXE=
    for binname in "$@"; do
        # Some implementations of `which` print error messages
        # Not useful here.
        BINEXE=$(which "$binname" 2>/dev/null)

        if [[ -n "$BINEXE" ]]; then
            echo "$BINEXE"
            return 0
        fi
    done
    return 1
}

### bincheck:has NAMES ... Usage:bbuild
#
# Determine if at least one of the binaries listed is present and installed on the system
#
###/doc

bincheck:has() {
    [[ -n "$(bincheck:get "$@")" ]]
}

### bincheck:path NAME Usage:bbuild
#
# Determine the actual path to the command
#
# Relative paths are not expanded.
#
###/doc

bincheck:path() {
    local binname="$1"; shift || :

    [[ "$binname" =~ / ]] && { 
        # A relative path cannot be resolved, just check existence
        [[ -e "$binname" ]] && echo "$binname" || return 1

    } || binname="$(which "$binname" 2>/dev/null)"

    # `which` failed
    [[ -n "$binname" ]] || return 1

    [[ -h "$binname" ]] && {

        local pointedname="$(ls -l "$binname"|grep -oP "$binname.+"|sed "s|$binname -> ||")"
        bincheck:path "$pointedname" ; return "$?"
    
    } || echo "$binname"
}
##bash-libs: patterns.sh @ 6421286a (2.0.1)

### Useful patterns Usage:bbuild
#
# Some useful regex patterns, exported as environment variables.
#
# They are not foolproof, and you are encouraged to improve upon them.
#
# $PAT_blank - detects whether an entire line is empty or whitespace
# $PAT_comment - detects whether is a line is a script comment (assumes '#' as the comment marker)
# $PAT_num - detects whether the string is an integer number in its entirety
# $PAT_cvar - detects if the string is a valid C variable name
# $PAT_filename - detects if the string is a safe UNIX or Windows file name;
#   does not allow presence of whitespace or special characters aside from '_', '.', '-'
# $PAT_email - simple heuristic to determine whether a string looks like a valid email address
#
###/doc

export PAT_blank='^\s*$'
export PAT_comment='^\s*(#.*)?$'
export PAT_num='^[0-9]+$'
export PAT_cvar='^[a-zA-Z_][a-zA-Z0-9_]*$'
export PAT_filename='^[a-zA-Z0-9_.-]$'
export PAT_email="$PAT_filename@$PAT_filename.$PAT_cvar"

##bash-libs: args.sh @ 6421286a (2.0.1)

### args Usage:bbuild
#
# An arguments handling utility.
#
###/doc

### args:get TOKEN ARGS ... Usage:bbuild
#
# Given a TOKEN, find the argument value
#
# Typically called with the parent's arguments
#
# 	args:get --key "$@"
# 	args:get -k "$@"
#
# If TOKEN is an int, returns the argument at that index (starts at 1, negative numbers count from end backwards)
#
# If TOKEN starts with two dashes ("--"), expect the value to be supplied after an equal sign
#
# 	--token=desired_value
#
# If TOKEN starts with a single dash, and is a letter or a number, expect the value to be the following token
#
# 	-t desired_value
#
# Returns 1 if could not find anything appropriate.
#
###/doc

args:get() {
    local seek="$1"; shift || :

    if [[ "$seek" =~ $PAT_num ]]; then
        local arguments=("$@")

        # Get the index starting at 1
        local n=$((seek-1))
        # but do not affect wrap-arounds
        [[ "$n" -ge 0 ]] || n=$((n+1))

        echo "${arguments[$n]}"

    elif [[ "$seek" =~ ^--.+ ]]; then
        args:get_long "$seek" "$@"

    elif [[ "$seek" =~ ^-[a-zA-Z0-9]$ ]]; then
        args:get_short "$seek" "$@"

    else
        return 1
    fi
}

args:get_short() {
    local token="$1"; shift || :
    while [[ -n "$*" ]]; do
        local item="$1"; shift || :

        if [[ "$item" = "$token" ]]; then
            echo "$1"
            return 0
        fi
    done
    return 1
}

args:get_long() {
    local token="$1"; shift || :
    local tokenpat="^$token=(.*)$"

    for item in "$@"; do
        if [[ "$item" =~ $tokenpat ]]; then
            echo "${BASH_REMATCH[1]}"
            return 0
        fi
    done
    return 1
}

### args:has TOKEN ARGS ... Usage:bbuild
#
# Determines whether TOKEN is present on its own in ARGS
#
# Typically called with the parent's arguments
#
# 	args:has thing "$@"
#
# Returns 0 on success for example
#
# 	args:has thing "one" "thing" "or" "another"
#
# Returns 1 on failure for example
#
# 	args:has thing "one thing" "or another"
#
# "one thing" is not a valid match for "thing" as a token.
#
###/doc

args:has() {
    local token="$1"; shift || :
    for item in "$@"; do
        if [[ "$token" = "$item" ]]; then
            return 0
        fi
    done
    return 1
}

### args:after TOKEN ARGS ... Usage:bbuild
#
# Return all tokens after TOKEN via the RETARR_ARGSAFTER
#
#    myargs=(one two -- three "four and" five)
# 	args:after -- "${myargs[@]}"
#
# 	for a in "${RETARR_ARGSAFTER}"; do
# 		echo "$a"
# 	done
#
# The above prints
#
# 	three
# 	four and
# 	five
#
###/doc

args:after() {
    local token="$1"; shift || :
    
    local current_token="$1"; shift || :
    while [[ "$#" -gt 0 ]] && [[ "$current_token" != "$token" ]]; do
        current_token="$1"; shift || :
    done

    RETARR_ARGSAFTER=("$@")
}
##bash-libs: runmain.sh @ 6421286a (2.0.1)

### runmain SCRIPTNAME FUNCTION [ARGUMENTS ...] Usage:bbuild
#
# Runs the function FUNCTION with ARGUMENTS, only if the runtime
# name of the script matches SCRIPTNAME
#
# This allows you include a main-like function in your library
# that only runs if you use your lib as an executabl itself.
#
# For example, an image archiver could be:
#
# 	function archive_images {
# 		tar czf "$1.tgz" "$@"
# 	}
#
# 	runmain archiveimages.sh archive_images "$@"
#
# When included a different script, the runmain call does not fire the lib's function
#
# If the lib is compiled/made executable, and named "archiveimages.sh", the function runs.
#
# This is similar to `if __name__ == "__main__"` clauses in python
#
###/doc

function runmain {
    local required_name="$1"; shift || :
    local funcall="$1"; shift || :
    local scriptname="$(basename "$0")"

    if [[ "$required_name" = "$scriptname" ]]; then
        "$funcall" "$@"
    fi
}
##bash-libs: readkv.sh @ 6421286a (2.0.1)

### Key Value Pair Reader Usage:bbuild
#
# Read a value given the key, from a specified file
#
###/doc

### readkv KEY FILE [DEFAULT] Usage:bbuild
#
# The KEY is the key in the file. A key is identified as starting at the beginning of a line, and ending at the first '=' character
#
# The value starts immediately after the first '=' character.
#
# If no value is found, the DEFAULT value is returned, or an empty string
#
###/doc

function readkv {
    local thedefault thekey thefile
    thekey="$1" ; shift
    thefile="$1"; shift

    if [[ -n "${1:-}" ]]; then
        thedefault="$1"; shift || :
    fi

    local res="$(readkv:meaningful_data "$thefile"|grep -E "^$thekey"'\s*='|sed -r "s/^$thekey"'\s*=\s*//')"
    if [[ -z "$res" ]]; then
        echo "${thedefault:-}"
    else
        echo "$res"
    fi
}

### readkv:require KEY FILE Usage:bbuild
#
# Like readkv, but causes a failure if the file does not exist.
#
###/doc

function readkv:require {
    if [[ -z "${2:-}" ]]; then
        out:fail "No file specified to read [$*]"
    fi

    if [[ ! -f "$2" ]] ; then
        out:fail "No such file $2 !"
    fi

    if ! head -n 1 "$2" > /dev/null; then
        out:fail "Could not read $2"
    fi
    readkv "$@"
}

### readkv:meaningful_data FILE Usage:bbuild
# Dump the file contents, stripping meaningless data (empty lines and comment lines)
###/doc
readkv:meaningful_data() {
    grep -v -P '^\s*(#.*)?$' "$1"
}

##bash-libs: isroot.sh @ 6421286a (2.0.1)

### isroot Usage:bbuild
# Test for root access
#
# If using cygwin, user is always root.
###/doc

function isroot {
    [[ "$UID" = 0 ]] || isroot:cygwin
}

### isroot:cygwin Usage:bbuild
# Returns whether running under cygwin.
#
# Typically a user under cygwin is root, except when they're not
#
# This utility exists as a reminder to check for cygwin.
###/doc

function isroot:cygwin {
    uname -o | grep -i cygwin -q
}

### isroot:require MESSAGE Usage:bbuild
# Require root. If script is not running as root,
# print message and exit
###/doc
function isroot:require {
    isroot || out:fail "$*"
}

### Warning messages Usage:help
#
# You can set a warning message with the -w flag to display a warning before carrying out any one action.
#
# This allows you to set a warning, with an opportunity to abort, before any defined action.
#
#   paf -w ACTION
#   sudo paf -w ACTION MESSAGE
# 
# The available actions are:
#
# install, clean, upgrade, update, list, show, search
#
# If MESSAGE is '.', then the message is cleared and will no longer show on actions.
#
# If no MESSAGE is provided, or it is an empty string, the current message is displayed.
#
# By default, warning waits 5 seconds before proceeding. Set "PAF_warning_sleep" to an int via environment variable, or "warning_sleep" in /etc/alpacka/config.ini
#
###/doc


PAF_warningdir="$PAF_configdir/warnings"

paf:warn() {
    local err=0
    [[ "$sleepsec" =~ ^[0-9]+$ ]] || out:fail "Warning sleep duration is not an int: $sleepsec"

    if paf:warn:display "${1:-}"; then
        paf:warn:grace-wait || out:fail "Error while waiting to continue ..."
    fi
}

paf:warn:grace-wait() {
    local sleepsec="${PAF_warning_sleep:-5}"

    out:info "Press Ctrl+C within $sleepsec seconds to abort, or Enter to continue ..."

    read -t $sleepsec || err="$?"
    if [[ -z "${err:-}" ]] || [[ "$err" -ge 128 ]]; then
        return 0
    fi
}

paf:warn:check-name() {
    [[ -n "${1:-}" ]] || {
        out:warn "(No warning section specified ... sleeping 5sec, press Ctrl+C to abort)"
        sleep 5
    }

    [[ "$1" =~ ^[a-z]+$ ]] || out:fail "invalid warning type '$1'"
}

paf:warn:is-set() {
    [[ -f "$1" ]] &&
        [[ $(grep -Ec ^ "$1") -gt 0 ]]
}

paf:warn:display() {
    paf:warn:check-name "${1:-}"

    local warnfile
    warnfile="$PAF_warningdir/${1}.txt"

    paf:warn:is-set "$warnfile" || return 0 # not an error - if not set, ignore step

    echo -n "$CBYEL" >&2
    cat "$warnfile"
    echo
    echo -n "$CDEF" >&2

    PAF_warned=true

    return 0
}

paf:warn:get-warning-args() {
    args:after -w "$@"

    [[ -n "${RETARR_ARGSAFTER[*]:-}" ]] || out:fail "No warning parameters ..."

    PAF_warntype=("${RETARR_ARGSAFTER[0]}")

    PAF_warnmessage=("${RETARR_ARGSAFTER[@]:1}")
    PAF_warnmessage="${PAF_warnmessage[*]:-}"
}

paf:warn:write() {
    isroot:require "You must be root to set warnings."

    mkdir -p "$PAF_warningdir"


    if [[ "$PAF_warnmessage" = "." ]]; then
        echo -n > "$PAF_warnpath"
    else
        echo -n "<$PAF_warntype>: ${PAF_warnmessage}" > "$PAF_warnpath"
    fi

    out:info "Warning written to $PAF_warnpath"
}

paf:warn:warn-set() {
    paf:warn:get-warning-args "$@"

    paf:warn:check-name "$PAF_warntype"

    PAF_warnpath="$PAF_warningdir/${PAF_warntype}.txt"

    if [[ -n "$PAF_warnmessage" ]]; then
        paf:warn:write
    
    else
        paf:warn:is-set "$PAF_warnpath" || out:fail "No warning set for '$PAF_warntype'"

        out:info "Contents of '$PAF_warnpath'"
        paf:warn:display "$PAF_warntype"
    fi
    exit
}

paf:main() {
    # Always check for pause on exit, even if ^C
    trap pause_check EXIT

    PAF_activities=(:)
    PAF_packages=(:)
    PAF_sources=(:)
    PAF_action=search
    PAF_assume=
    PAF_end_pause=false
    PAF_force_tmux=false

    paf:preflight_check

    paf:load_configuration

    paf:get_package_manager

    paf:help "$@"
    if [[ -z "$*" ]]; then
        out:warn "Nothing to do. Try --help ."
        exit 0
    fi

    paf:parse_arguments "$@"
    
    paf:tmux "$0" "$@"

    paf:run_activity update

    if [[ -n "${PAF_action:-}" ]]; then
        # We pass "$@" in case it is needed
        #  but most actions just access ${PAF_packages[@]} directly
        "$PAF_pm:$PAF_action" "$@"
    fi

    paf:run_activity clean
}

pause_check() {
    if [[ "$PAF_end_pause" = true ]]; then
        read -p "press return to end ..."
    fi
}

paf:preflight_check() {
    bincheck:has grep || out:fail "'grep' command is required but was not found"

    bincheck:has less || . <(echo 'less() { cat - ; }')
}

paf:load_configuration() {
    local cfile="$PAF_configdir/config.ini"
    if [[ ! -f "$cfile" ]]; then
        return 0
    fi

    if [[ -z "${PAF_warning_sleep:-}" ]]; then
        PAF_warning_sleep="$(readkv warning_sleep "$cfile")"
    fi
}

paf:help() {
    if [[ "$*" =~ --help ]]; then
        autohelp:print help "$0"
        autohelp:print "help-${PAF_pm}" "$0"
        exit 0
    fi
}

paf:sudo() {
    if ! isroot && bincheck:has sudo; then
        sudo "$@"
        return "$?"
    else
        isroot:require "You must be root to run this script."
        "$@"
    fi
}

paf:tmux() {
    # This is called at the top of the script.
    # If we are already in tmux, we return and let the script run
    # However if we are not in tmux, we attempt to wrap
    #   and exit, rather than repeating the process in the
    #   non-tmux session

    # We are already in screen/tmux; or we are not in SSH, and we are not forcing tmux
    if [[ "$TERM" = screen ]] || ([[ -z "${SSH_TTY:-}" ]] && [[ "$PAF_force_tmux" != true ]]); then
        return
    fi

    if [[ "$PAF_force_tmux" = true ]] ||
        [[ -n "${PAF_activities[*]:-}" ]] || # All activities trigger tmux
        [[ ! "$PAF_action" =~  ^(search|show|list)$ ]] # Don't need privilege - this could change depending on package manager
        then

        if ! bincheck:has tmux; then
            out:warn "Running a package manager over SSH without wrapping it is unsafe - install tmux."
            askuser:confirm "${CRED}Continue ?${CDEF}" || exit 1
            return

        else
            tmux new "$@" --pause
            exit
        fi
    fi
}

paf:get_package_manager() {
    local drivers=(apt-get:dpkg dnf:rpm yum:rpm tazpkg: apk: zypper:rpm pacman)
    local drive

    for drive in "${drivers[@]}"; do
        PAF_pm="${drive%:*}" # general package manager e.g. apt
        PAF_bpm="${drive#*:}" # base package manager e.g. dpkg

        bincheck:has "$PAF_pm" || continue
        return
    done

    out:fail "You distro is unsupported"
}

paf:add_activity() {
    PAF_activities[${#PAF_activities[@]}]="$1"
}

paf:run_activity() {
    local activity="$1"
    if [[ "${PAF_activities[*]:-}" =~ "$activity" ]]; then
        "$PAF_pm:$activity"
    fi
}

paf:parse_arguments() {
    for arg in "$@"; do
        case "$arg" in
        --version)
            paf:printversion
            exit 0
            ;;
        --pause)
            PAF_end_pause=true
            ;;
        --tmux)
            PAF_force_tmux=true
            ;;
        -w)
            paf:warn:warn-set "$@"
            exit 0
            ;;
        -u*) paf:add_activity "update"
            PAF_flag_update="$arg"
            if [[ "$PAF_action" = search ]] && [[ "${#PAF_packages[@]}" -lt 2 ]]; then
                PAF_action=""
            fi
            ;;

        -c*)
            paf:add_activity "clean"
            PAF_flag_clean="$arg"
            if [[ "$PAF_action" = search ]]; then
                PAF_action=""
            fi
            ;;

        -g*)    PAF_action="upgrade" ; PAF_flag_upgrade="$arg" ;;
        -i*)    PAF_action="install" ; PAF_flag_install="$arg" ;;
        -r*)    PAF_action="remove"  ; PAF_flag_remove="$arg"  ;;
        -l*)    PAF_action="list"    ; PAF_flag_list="$arg"    ;;
        -s*)    PAF_action="show"    ; PAF_flag_show="$arg"    ;;
        -z*)    PAF_action="search"  ; PAF_flag_search="$arg"  ;;

        -y) PAF_assume="yes" ;;
        -n) PAF_assume="no" ;;

        *)
            PAF_packages[${#PAF_packages[@]}]="$arg"
            [[ -n "$PAF_action" ]] || PAF_action=search
            ;;
        esac
    done

    # blat the holders
    PAF_activities=("${PAF_activities[@]:1}")
    PAF_packages=("${PAF_packages[@]:1}")

    # Issue all warnings in bulk as soon as we know our activities
    #   so user sees them early
    paf:issue_warnings "${PAF_activities[@]:-}" "$PAF_action"
}

paf:issue_warnings() {
    local warning
    PAF_warned=false

    for warning in "$@"; do
        [[ -n "$warning" ]] || continue
        paf:warn:display "$warning"
    done

    if [[ "$PAF_warned" = true ]]; then
        paf:warn:grace-wait
    fi
}

paf:printversion() {
    echo "Alpacka, $PAF_version"
    echo "$PAF_copyright"
}

ppa:add() {
    bincheck:has add-apt-repository ||
        out:fail "PPAs are not supported on this system. Install 'add-apt-repository'"

    paf:sudo add-apt-repository "$1"
}

### APT-specific options Usage:help-apt-get
#
# APT specific options include
#
# `-ip` - use first package name as PPA source, install the remaining packages after adding the PPA:
#
#    paf -ip ppa:libreoffice/ppa libreoffice
#
# `-if` - use dependency fix before running installation
#
# ( can use `-ipf` to run both fix and PPA in one )
#
# `-gg` - perform a dist-upgrade
#
# `-gR` - perform a release upgrade
#
# `-rp` - purge
#
###/doc

apt-get:assume() {
    if [[ "$PAF_assume" = yes ]]; then
        echo "-y"
    fi
}

apt-get:update() {
    paf:sudo apt-get update
}

apt-get:clean() {
    paf:sudo apt-get $(apt-get:assume) autoclean
    paf:sudo apt-get $(apt-get:assume) autoremove
}

apt-get:install() {
    local firstpackage
    firstpackage="${PAF_packages[0]}"

    if [[ "$PAF_flag_install" =~ f ]]; then
        apt-get:fix
    fi

    if [[ "$PAF_flag_install" =~ p ]]; then
        PAF_packages=("${PAF_packages[@]:1}")

        ppa:add "$firstpackage"
        apt-get:update
    fi

    if [[ -n "${PAF_packages[*]}" ]]; then
        paf:sudo apt-get install $(apt-get:assume) "${PAF_packages[@]:-}"
    fi
}

apt-get:fix() {
    paf:sudo apt-get $(apt-get:assume) -f install
}

apt-get:remove() {
    if [[ "$PAF_flag_remove" = "-rp" ]]; then
        paf:sudo apt-get purge $(apt-get:assume) "${PAF_packages[@]:-}"

    else
        paf:sudo apt-get remove $(apt-get:assume) "${PAF_packages[@]:-}"
    fi
}

apt-get:list() {
    dpkg --get-selections | less || return 0
}

apt-get:show() {
    local package

    for package in "${PAF_packages[@]:-}"; do
        apt-cache show "$package" | sed -r 's/^(Package: )/[1;33m===[0m\n\1/' | less -R
    done
}

apt-get:has-release-upgrade() {
    bincheck:has do-release-upgrade || {
        if [[ "$(. /etc/os-release ; echo "$ID")" = ubuntu ]]; then
            out:warn "'ubuntu-release-upgrader-core' required - installing ..."
            apt-get install ubuntu-release-upgrader-core
        else
            out:fail "Only supported on Ubuntu"
        fi
    }
}

apt-get:upgrade() {
    if [[ "$PAF_flag_upgrade" = "-gg" ]] ; then
        paf:sudo apt-get $(apt-get:assume) dist-upgrade

    elif [[ "$PAF_flag_upgrade" = "-gR" ]]; then
        apt-get:has-release-upgrade
        paf:sudo do-release-upgrade $(apt-get:assume)

    else
        paf:sudo apt-get $(apt-get:assume) upgrade
    fi
}

apt-get:search() {
    apt-cache search "${PAF_packages[@]:-}" | less
}
dnf:assume() {
    if [[ "$PAF_assume" = yes ]]; then
        echo "-y"
    fi
}

dnf:update() {
    :
}

dnf:clean() {
    paf:sudo "$PAF_pm" clean
    paf:sudo "$PAF_pm" autoremove
}

dnf:install() {
    paf:sudo "$PAF_pm" install $(dnf:assume) "${PAF_packages[@]:-}"
}

dnf:remove() {
    paf:sudo "$PAF_pm" remove $(dnf:assume) "${PAF_packages[@]:-}"
}

dnf:list() {
    paf:sudo "$PAF_pm" list --installed | less
    return 0
}

dnf:show() {
    local package

    for package in "${PAF_packages[@]:-}"; do
        "$PAF_pm" info "$package" | less
    done
}

dnf:upgrade() {
    paf:sudo "$PAF_pm" upgrade
}

dnf:search() {
    "$PAF_pm" search "${PAF_packages[@]:-}" | less
}

yum:update() { dnf:update "$@" ; }
yum:clean() { dnf:clean "$@" ; }
yum:install() { dnf:install "$@" ; }
yum:remove() { dnf:remove "$@" ; }
yum:list() { dnf:list "$@" ; }
yum:show() { dnf:show "$@" ; }
yum:upgrade() { dnf:upgrade "$@" ; }
yum:search() { dnf:search "$@" ; }
### Tazpkg-specific options Usage:help-tazpkg
#
# Search:
#
# by default, searching will perform an AND search, returning all packages with all the search terms
#
# `-zo` will perform an or search, returning all packages with at least one of the search terms
#
###/doc

tazpkg:update() {
    paf:sudo tazpkg recharge
}

tazpkg:clean() {
    paf:sudo tazpkg clean-cache
    paf:sudo tazpkg autoremove
}

tazpkg:install() {
    local pkg
    for pkg in "${PAF_packages[@]:-}"; do
        paf:sudo tazpkg -gi "$pkg"
    done
}

tazpkg:remove() {
    local pkg
    for pkg in "${PAF_packages[@]:-}"; do
        paf:sudo tazpkg remove "$pkg"
    done
}

tazpkg:list() {
    tazpkg list | less || return 0
}

tazpkg:show() {
    local package

    for package in "${PAF_packages[@]:-}"; do
        tazpkg info "$package" | less -R
    done
}

tazpkg:upgrade() {
    paf:sudo tazpkg upgrade
}

tazpkg:search:and() {
    TERM="$1"; shift

    local tazres=$(tazpkg search "$TERM"|egrep -e '-[0-9]')

    while [[ -n "$@" ]]; do
        tazres=$(echo "$tazres" | grep "$1")
        shift
    done
    echo "$tazres"
}

tazpkg:search:or() {
    local tazres=
    while [[ -n "$@" ]]; do
        TERM="$1" ; shift
        tazres="$tazres $(tazpkg search "$TERM"| egrep -e '-[0-9]')"
        shift
    done
    echo "$tazres"|sort
}

tazpkg:search() {
    if [[ "${PAF_flag_search:-}" = "-zo" ]]; then
        tazpkg:search:or "${PAF_packages[@]:-}" | less
    else
        tazpkg:search:and "${PAF_packages[@]:-}" | less
    fi
}
apk:update() {
    paf:sudo apk update
}

apk:clean() {
    paf:sudo apk clean
}

apk:install() {
    paf:sudo apk add "${PAF_packages[@]:-}"
}

apk:remove() {
    paf:sudo apk del "${PAF_packages[@]:-}"
}

apk:list() {
    apk info -vv |sort| less || return 0
}

apk:show() {
    local package

    for package in "${PAF_packages[@]:-}"; do
        apk info "$package" | less
    done
}

apk:upgrade() {
    paf:sudo apk upgrade
}

apk:search() {
    apk search "${PAF_packages[@]:-}" | less
}
### zypper-specific options Usage:help-zypper
#
# -g
#   Upgrade packages
#
# -gR
#   Distribution upgrade
#
###/doc

zypper:assume() {
    if [[ "$PAF_assume" = yes ]]; then
        echo "-y"
    fi
}

zypper:update() {
    paf:sudo zypper $(zypper:assume) refresh
}

zypper:clean() {
    paf:sudo zypper $(zypper:assume) clean
}

zypper:install() {
    paf:sudo zypper install $(zypper:assume) "${PAF_packages[@]:-}"
}

zypper:remove() {
    paf:sudo zypper remove $(zypper:assume) "${PAF_packages[@]:-}"
}

zypper:list() {
    zypper se --installed-only | grep -v -e 'patch\s*$' | less || return 0
}

zypper:show() {
    local package

    for package in "${PAF_packages[@]:-}"; do
        zypper info "$package" | less
    done
}

zypper:upgrade() {
    if [[ "$PAF_flag_upgrade" = "-gR" ]] ; then
        paf:sudo zypper $(zypper:assume) dist-upgrade

    else
        paf:sudo zypper $(zypper:assume) update
    fi
}

zypper:search() {
    zypper search "${PAF_packages[@]:-}" | less
}
### pacman-specific options Usage:help-pacman
#
# -c<N> - when cleaning, keep N previous versions of packages
#
#   paf -c2
#
###/doc

PAF_pacman_updated=false

pacman:assume() {
    if [[ "$PAF_assume" = yes ]]; then
        echo "--noconfirm"
    fi
}

pacman:update() {
    paf:sudo pacman -Syy
    PAF_pacman_updated=true
}

pacman:clean() {
    local keepstring keepnum

    bincheck:has paccache || {
        out:warn "You need 'paccache' from 'pacman-contrib' to perform cleans. Installing ..."
        pacman -S pacman-contrib
    }
    
    keepnum="${PAF_flag_clean:2}"
    if [[ "${keepnum:-}" =~ ^[0-9]+$ ]]; then
        keepstring="k$keepnum"
    fi

    paf:sudo paccache $(pacman:assume) -r"${keepstring:-}" # `-rk1` to keep 1 recent level of packages
}

pacman:install() {
    paf:sudo pacman $(pacman:assume) -S "${PAF_packages[@]:-}"
}

pacman:remove() {
    paf:sudo pacman $(pacman:assume) -Rs "${PAF_packages[@]:-}"
}

pacman:list() {
    pacman -Q | less || return 0
}

pacman:show() {
    local package

    for package in "${PAF_packages[@]:-}"; do
        pacman -Si "$package" | less
    done
}

pacman:upgrade() {
    if [[ "$PAF_pacman_updated" = true ]]; then
        paf:sudo pacman $(pacman:assume) -Su
    else
        paf:sudo pacman $(pacman:assume) -Syu
    fi
}

pacman:search() {
    pacman -Ss "${PAF_packages[@]:-}" | less
}
# TODO To be implemented
# emerge.sh
# eopkg.sh

runmain paf paf:main "$@"
